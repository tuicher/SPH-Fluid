// ComputeDeltaP.comp
#version 460
layout(local_size_x = 128) in;

struct Particle { vec4 x; vec4 v; vec4 p; vec4 color; vec4 meta; };

layout(std430, binding = 0) buffer Particles { Particle particles[]; };
layout(std430, binding = 3) buffer Lambdas   { float    lambdas[];   };
layout(std430, binding = 4) buffer DeltaP    { vec4     deltaP[];    };

uniform uint  uNumParticles;
uniform float uRadius;
uniform float uRestDensity;
uniform float uSCorrK;   // 0.1 aprox
uniform float uSCorrN;   // 4.0 aprox

const float PI = 3.14159265359;
const float q  = 0.3;    // parametro s_corr

float poly6(float r2, float h)
{
    float h2 = h * h;
    float diff = h2 - r2;
    if (diff <= 0.0) return 0.0;

    float h4 = h2 * h2;
    float h8 = h4 * h4;
    float h9 = h8 * h;
    return (315.0 / (64.0 * PI * h9)) * diff * diff * diff;
}

vec3 gradSpiky(vec3 r, float h)
{
    float len = length(r);
    if (len == 0.0 || len >= h) return vec3(0.0);

    float h2 = h * h;
    float h3 = h2 * h;
    float h6 = h3 * h3;
    float coeff = -45.0 / (PI * h6);
    float diff  = h - len;
    return coeff * diff * diff * (r / len);
}

void main()
{
    uint i = gl_GlobalInvocationID.x;
    if (i >= uNumParticles) return;

    vec3  pi  = particles[i].p.xyz;
    float li  = lambdas[i];
    vec3  dPi = vec3(0.0);

    float w_q = poly6(q * q * uRadius * uRadius, uRadius);

    for (uint j = 0u; j < uNumParticles; ++j)
    {
        if (i == j) continue;

        vec3 rij = pi - particles[j].p.xyz;
        float r2 = dot(rij, rij);
        if (r2 < uRadius * uRadius)
        {
            float lj = lambdas[j];
            float m_j = particles[j].meta.x;

            float w   = poly6(r2, uRadius);
            float s_corr = -uSCorrK * pow(w / w_q, uSCorrN);

            vec3 grad = gradSpiky(rij, uRadius);
            dPi += (li + lj + s_corr) * (m_j / uRestDensity) * grad;
        }
    }

    deltaP[i] = vec4(dPi, 0.0);
}
